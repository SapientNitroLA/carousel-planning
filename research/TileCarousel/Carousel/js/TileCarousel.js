/**
 * Create an accessible JavaScript carousel out of any unordered list of tiles. Each tile should be placed in a list item `li` within a container `ul`. Additional markup is generated by JavaScript, and several required style definitions are included in a global stylesheet. These styles are external instead of plugin-generated so they can be overridden easily if neccessary.
 * 
 * Tiles can contain any html content but must be equal in width. Measurement for the overall carousel and individual tiles is based on the width of the first tile. Height can vary, although because the images are lazy loaded, image heights are evaluated just-in-time. This can lead to a slight page jump if a hidden tile is taller than the visible tiles once its images are loaded. CSS can be used to style the "previous" and "next" buttons, as well as the pagination menu (if pagination is enabled).
 * 
 * Instantiate the carousel(s) by calling the plugin on an element or elements and passing an optional options object.
 * 
 * Requires jQuery 1.4.2.
 *
 * @demo demo.php
 * 
 * @example
 * $('.carousel').tileCarousel();
 * @title Example #1: Default Instantiation
 * @syntax javascript
 * @desc Instantiation using default settings: single item carousel, one tile displayed at a time, advances one tile at a time, does not loop and does not display pagination. Note: the `carousel` class is not required for instantiation - any selector can be used.
 * 
 * 
 * @example
 * $('.carousel').tileCarousel({
 *      increment: 3,
 *      incrementMode: 'frame', 
 *      loop: false,
 *      pagination: true
 * });
 * @title Example #2: Options
 * @syntax javascript
 * @desc This exmaple uses an `options` object to create a three-tile carousel that displays pagination and does not loop.
 * 
 * 
 * @example
 * $('.carousel').tileCarousel({
 *      increment: 4,
 *      incrementMode: 'tile', 
 *      loop: true,
 *      pagination: false
 * });
 * @title Example #3: More Options
 * @syntax javascript
 * @desc This exmaple uses an `options` object to create a four-tile carousel that loops, does not display pagination and moves the carousel only one tile at a time (instead of the entire visible frame).
 * 
 * 
 * @example
 * $('.carousel').tileCarousel({
 *      increment: 3,
 *      loop: true,
 *      callbacks: {
 *          preFrameChange: function() {
 *              // do something
 *          },
 *          postFrameChange: function() {
 *              // do something
 *          },
 *      }
 * });
 * @title Example #4: Using Callbacks
 * @syntax javascript
 * @desc This exmaple uses an `options` object to create a three-tile carousel that loops and triggers callback functions before and after the carousel frame changes. The two callbacks must be named `preFrameChange` and `postFrameChange`.
 * 
 * 
 * @param Object options 
 * @option Number increment Number of tiles to display per frame. Default is 1.
 * @option String incrementMode Whether to move the carousel by frame or single tile. Accepted values are `frame` and `tile`. Default is `frame`.
 * @option String easing Default is `swing`. Additional jQuery UI plug-in required for other easing options.
 * @option Number speed Speed of animation. Default is `750` miliseconds.
 * @option Boolean loop Default is `false`. If `true`, carousel will loop infinitely in either direction.
 * @option Boolean pagination Default is `false`. If `true`, pagination links are generated and can be styled.
 * @option Boolean centerPagination Calulates width of pagination wrapper and centers it beneath the carousel. Default is `true`.
 * @option Boolean encapsulateControls Default is `false`. If `true`, a wrapper is placed around the prev/next links and pagination and centered.
 * @option Boolean displayCount Default is `false`. If `true`, the current tile/frame context will be indicated (ie. "1-3 of 10").
 * @option Boolean accessible Default is `true`. Enables screenreader markup and keystroke control of carousel.
 * @option Number wrapperDelta Change wrapper width by this pixel value. Default is 0.
 * @option Number viewportDelta Change viewport width by this pixel value. Default is 0.
 * @option Function preFrameChange Callback fired before the transitional frame animation.
 * @option Function postFrameChange Callback fired after the transitional frame animation.
 * 
 * @name tileCarousel
 * @type jQuery
 * @author Ryan Fitzer and Travis Higdon
 */
 
/*
    TODO:
        - Compile regex/string replacement tokens once.
        - Get measurements first and then remove markup while altering.
        - Document tokens.
        - All methods should use cache method.
        - Disambiguate `increment` from carousel width and `incrementMode`
*/

;(function( window, $ ) {
    
    // Use local document
    var document = window.document;
    
    // Make sure to use the correct case for IE
    var test = document.createElement( 'li' ).getAttributeNode( 'tabindex' ),
        tabindex = test ? 'tabIndex' : 'tabindex';
    test = null;
    
    // Compile templates
    var tmplWrapper         = $('<div class="carousel-container"/>'),
        tmplViewport        = $('<div class="carousel-viewport"/>'),
        tmplPN              = $('<a href="#"/>'),
        tmplPNDisabled      = $('<span class="disabled"/>'),
        tmplControls        = $('<div class="carousel-controls"/>'),
        tmplControlsParent  = $('<div class="carousel-controls-wrapper"/>'),
        tmplPagination      = $('<ul class="carousel-pagination"/>'),
        tmplCounter         = $('<div class="carousel-display-counter"/>'),
        tmplSpacerTile      = $('<li class="carousel-panel-spacer state-hidden"/>'),
        tmplFrameLink       = '<li><a class="carousel-frame{selected}" data-carousel-frame="{number}" href="#" title="{current}">{frameText}</a></li>';
    
    // Helper for updating buttons
    var toggleControl = function( oldBtn, newBtn, obj ) {
            obj[ oldBtn ].replaceWith( obj[ newBtn ] );
            obj[ oldBtn ] = obj[ newBtn ];
    };
    
    $.TileCarousel = function( element, options ) {
        
        var self = this,
            defaults = {
            prevText: 'Previous item{plural} in list',
            nextText: 'Next item{plural} in list',
            frameText: 'Page {number} of {total}',
            frameCurrentText: 'Current Page',
            counterText: '{number} of {total}',
            increment: 1,
            incrementMode: 'frame', // tile or frame
            speed: 750,
            easing: 'swing',
            loop: false,
            pagination: false,
            centerPagination: true,
            encapsulateControls: false,
            displayCount: false,
            accessible: true,
            showTile: 0,
            wrapperDelta: 0,
            viewportDelta: 0,
            preFrameChange: null,
            postFrameChange: null
        };
        
        this.cacheObj = {};
        this.elementNode = element;
        this.element = $( element );
        this.options = $.extend( {}, defaults, options || {} );
        
        // Make sure we have integers
        $.each( ['increment', 'speed', 'showTile', 'wrapperDelta', 'viewportDelta'], function(i, item) {
            self.options[ this ] = parseInt( self.options[ this ], 10 );
        });
        
        this.setup();
        
    };
    
    $.TileCarousel.prototype = {
                
        setup: function() {
                        
            var state,
                controlsWidth,
                self        = this,
                carousel    = this.element,
                parentNode  = this.elementNode.parentNode,
                nextSibling = this.elementNode.nextSibling,
                wrapper     = tmplWrapper.clone(),
                viewport    = tmplViewport.clone(),
                controls    = tmplControls.clone(),
                options     = this.options,
                loop        = options.loop,
                increment   = options.increment,
                showTile    = options.showTile,
                counter     = tmplCounter.clone();
                                
            // Make the main elements avaible to `this`
            this.wrapper = wrapper;
            this.carousel = carousel;
            this.viewport = viewport;
            this.counter = counter;
            
            // Remove and build the carousel
			carousel.remove();
            wrapper.append( viewport );
            viewport.append( carousel );
            
            // Replace the carousel
			if ( nextSibling ) $( nextSibling ).before( wrapper );
			else $( parentNode ).append( wrapper );
			
			// Listen for focus on tiles
			carousel.delegate( '.carousel-panel', 'focusin focusout', function(e) {
			    var action = e.type === 'focusin' ? 'add' : 'remove';
                $( e.currentTarget )[ action + 'Class' ]( 'state-focus' );
            });
			            
            // Build out the frames and state object
            state = this.normalizeState();
            
            wrapper.css( 'width', state.tileWidth * options.increment + options.wrapperDelta + 'px' );
            viewport.css( 'width', state.tileWidth * options.increment + options.viewportDelta + 'px' );
            carousel.css( 'width',  ( state.tileWidth * state.curTileLength ) + 'px' );
            viewport[0].scrollLeft = state.offset;
            
            this.buildNavigation();
            
            // Add counter wrapper
            if ( options.displayCount ) this.wrapper.append( counter ) && this.updateDisplayCount();
                        
            // Cache array for lazy loader
            this.lazyloadCache = new Array( state.curTileLength );
            
            // Lazy load images
            // load only the visible frame
            this.lazyloadImages( state.index, state.index + options.increment );

            // if ( loop ) {
            //     // load the next chrological frame
            //     this.lazyloadImages( state.index * 2, ( state.index * 2 ) + options.increment );
            //     // Load the previous chrological frame
            //     this.lazyloadImages( state.index - options.increment, options.increment );
            //     // load the 2nd to last frame
            //     this.lazyloadImages( state.curTileLength - ( options.increment * 2 ), state.curTileLength - options.increment );
            // }
            
            if ( showTile > 0 ) this.jumpToTile( showTile );
            
        },
        
        cache: function( key, value ) {
            
            var cache = this.cacheObj,
                query = cache[ key ] !== 'undefined'
                    ? cache[ key ]
                    : undefined;
            
            if ( !value ) return query;
                
            cache[ key ] = value;
            
            return cache;
            
        },
        
        normalizeState: function() {
            
            var clones          = [],
                index           = 0,
                state           = this.state,
                carousel        = this.carousel,
                tileArr         = this.element.children( 'li' ).toArray(),
                origTiles       = tileArr,
                firstTile       = $( tileArr[0] ),
                tileWidth       = firstTile.outerWidth( true ),
                tileHeight      = firstTile.outerHeight( true ),
                options         = this.options,
                loop            = options.loop,
                increment       = options.increment,
                origTileLength  = tileArr.length,
                curTileLength   = origTileLength,
                frameLength     = Math.ceil( curTileLength / increment ),
                state           = this.state = {
                    index: index,
                    offset: 0,
                    spacers: 0,
                    loopReset: false,
                    prevIndex: false,
                    tileObj: $( tileArr ),
                    tileArr: tileArr,
                    origTileLength: origTileLength,
                    curTileLength: curTileLength,
                    tileWidth: tileWidth,
                    tileHeight: tileHeight,
                    curTile: false,
                    prevTile: false,
                    frameArr: [],
                    origFrameLength: frameLength,
                    curFrameLength: frameLength,
                    frameWidth: increment * tileWidth,
                    curFrame: [],
                    prevFrame: [],
                    frameIndex: 0,
                    prevFrameIndex: 0
                };
            
            this.toggleAria( tileArr, 'add', 'carousel-panel' );
            
            // Pad final frame with blank panels
            if ( options.pagination ) {
                while ( curTileLength % increment !== 0 ) {
                    tileArr.push( tmplSpacerTile[0].cloneNode(true) );
                    state.spacers++;
                    curTileLength++;
                }
            }

            if ( loop ) {
                                    
                // Add clones to create full chronological set of frames.
                // This could be pretty heavy and could be changed to just
                // fill out the incomplete frame intead.
                while ( curTileLength % increment !== 0 ) {
                    
                    for ( var i = 0; i < origTileLength; i++, curTileLength++ ) {
                        tileArr.push( origTiles[i].cloneNode(true) );
                    }
                }
                
                // Add a clone of the last frame to the beginning
                for ( var i = increment - 1; i >= 0; i--, state.spacers++ ) {
                    clones.push( tileArr[ origTileLength - 1 - i ].cloneNode(true) );
                }
                tileArr = clones.concat( tileArr );
                clones = [];
                               
                // Add a clone of the first frame to the end
                for ( var i = 0; i < increment; i++, state.spacers++ ) {
                    tileArr.push( origTiles[i].cloneNode(true) );
                }
                
                index = increment;
            }
            
            // Build the normalized frames array
            for (   var sec = 0, len = tileArr.length / increment, count = 1; 
                    sec < len; 
                    sec++, count++ ) {
                state.frameArr.push( tileArr.slice( increment * sec, increment * count ) );
            };
            
            state.index             = index;
            state.offset            = state.index ? state.frameWidth : state.offset;
            state.tileArr           = tileArr;                      
            state.tileObj           = $( state.tileArr );
            state.curTile           = state.tileObj.eq( state.index );
            state.curTileLength     = state.tileArr.length;
            state.curFrameLength    = Math.ceil( state.curTileLength / increment );
            state.frameIndex        = Math.ceil( state.index / increment );
            state.prevFrameIndex    = state.frameIndex;
            state.curFrame          = state.frameArr[ state.frameIndex ];
            state.tileDelta         = ( increment * state.curFrameLength ) - state.curTileLength;
            
            this.toggleAria( state.curFrame, 'remove' );
            
            carousel.html( state.tileArr );
            
            return state;
            
        },
        
        updateState: function( index, animate ) {

            var self            = this,
                state           = self.state,
                ops             = self.options,
                loop            = ops.loop,
                pagination      = ops.pagination,
                increment       = ops.increment,
                prevFrameIndex  = state.frameIndex,
                index           = index > state.curTileLength - increment ? state.curTileLength - increment
                                    : index < 0 ? 0
                                    : index,
                frameIndex      = Math.ceil( index / increment ),
                isFirstFrame    = index === 0,
                isLastFrame     = index === state.curTileLength - increment,
                shouldLoopReset = loop && !animate && ( isFirstFrame || isLastFrame );
            
            if ( shouldLoopReset ) {
                                
                if ( isFirstFrame ) index = state.curTileLength - ( increment * 2 );
                else if ( isLastFrame ) index = increment;
                
                frameIndex = Math.ceil( index / increment );
                prevFrameIndex = isFirstFrame ? 1 : state.curFrameLength - 1;
                
            }
                        
            $.extend( this.state, {
                index: index,
                offset: state.tileWidth * index,
                loopReset: shouldLoopReset,
                prevIndex: state.index,
                prevTile: state.curTile,
                curTile: isLastFrame && state.tileDelta && ops.incrementMode === 'frame'
                            ? state.tileArr[ index + state.tileDelta ]
                            : state.tileArr[ index ],
                curFrame: state.tileArr.slice( isLastFrame ? index : index, increment + index ),
                prevFrame: shouldLoopReset ? state.prevFrame : state.curFrame,
                frameIndex: frameIndex,
                prevFrameIndex: state.frameIndex
            });
              
            animate && this.animate();
            
            return state;
        },
        
        buildNavigation: function() {
            
            var text,
                self            = this,
                state           = self.state,
                index           = state.index,
                wrapper         = self.wrapper,
                options         = self.options,
                increment       = options.increment,
                plural          = increment > 1 ? 's' : '',
                number          = plural ? increment : '',
                controls        = tmplControls.clone(),
                controlsParent  = tmplControlsParent.clone(),
                controlsWrapper = options.encapsulateControls ? controls : wrapper,
                viewport        = self.viewport,
                viewportWidth   = state.tileWidth * options.increment + options.viewportDelta;
            
            text = options.prevText.replace( '{number}', number ).replace( '{plural}', plural );
            self.prev = tmplPN.clone().attr( 'class', 'prevFrame' ).text( text );
            
            text = options.nextText.replace( '{number}', number ).replace( '{plural}', plural );
            self.next = tmplPN.clone().attr( 'class', 'nextFrame' ).text( text );
            
            self.prevDisabled = tmplPNDisabled.clone().addClass( 'prevFrame' );
            self.nextDisabled = tmplPNDisabled.clone().addClass( 'nextFrame' );
            
            // Set original buttons
            self.prevBtn = self.prev;
            self.nextBtn = self.next;
                
            // Set click events buttons
            wrapper.delegate( '.prevFrame, .nextFrame', 'click', function( e ) {
                
                var element = $( this ),
                    method = element.attr( 'class' );
                                
                e.preventDefault();
                
                if ( self.carousel.hasClass( 'aria-busy' )
                    || element.hasClass( 'disabled' ) ) return false;
                
                self[ method ]();

            });
                
            // Disable buttons if there is only one frame
            if ( state.curTileLength <= options.increment ) {
                self.prevBtn = self.prevDisabled;
                self.nextBtn = self.nextDisabled;
            }
            
            // Disable prev button
            if ( index === 0 ) self.prevBtn = self.prevDisabled;
            
            // Insert controls
            if ( !options.encapsulateControls ) {
                
                wrapper.prepend( self.prevBtn );
                options.pagination && self.buildPagination( wrapper );
                wrapper.append( self.nextBtn );
            
            } else {
                
                controlsParent.append( controls );
                controls.append( self.prevBtn );
                options.pagination && self.buildPagination( controls );
                controls.append( self.nextBtn );
                wrapper.append( controlsParent );

                // Center controls beneath carousel
                controlsWidth = self.prevBtn.outerWidth( true )
                    + self.pagination.outerWidth( true )
                    + self.nextBtn.outerWidth( true );
                    
                controls.css({
                    'position': 'relative',
                    'width': controlsWidth + 'px',
                    'left': ( ( viewportWidth / 2 ) - ( controlsWidth / 2 ) ) + 'px'
                });
                
            }
            
        },
        
        updateNavigation: function() {
            
            var prevDisabled,
                nextDisabled,
                self = this,
                state = this.state,
                index = state.index,
                options = self.options,
                isFirst = index === 0,
                isLast = index + this.options.increment >= state.curTileLength;
                
            if ( options.loop ) return;
            
            prevDisabled = self.prevBtn !== self.prev;
            nextDisabled = self.nextBtn !== self.next;
                                        
            if ( isFirst ) toggleControl( 'prevBtn', 'prevDisabled', self );
            else if ( prevDisabled ) toggleControl( 'prevBtn', 'prev', self );

            if ( isLast ) toggleControl( 'nextBtn', 'nextDisabled', self );
            else if ( nextDisabled ) toggleControl( 'nextBtn', 'next', self );
            
            if ( !options.pagination ) return;
            
            self.paginationLinks.eq( state.prevFrameIndex ).removeClass( 'selected' ).attr( 'title', '' );
            self.paginationLinks.eq( state.frameIndex ).addClass( 'selected' ).attr( 'title', options.frameCurrentText );
            
        },
        
        buildPagination: function( wrapper ) {
            
            var current,
                isSelected,
                pageLink,
                pageLinks,
                pageLinkWidth,
                paginationWidth,
                self        = this,
                state       = self.state,
                options     = self.options,
                frameLinks  = [],
                frameLink   = tmplFrameLink,
                rNumber     = /\{number\}/g,
                rTotal      = /\{total\}/,
                rCurrent    = /\{current\}/,
                selected    = ' selected',
                rSelected   = /\{selected\}/,
                rFrameText  = /\{frameText\}/,
                loop        = this.options.loop,
                frameIndex  = state.frameIndex,
                pagination  = tmplPagination.clone(),
                curFrameLength  = state.curFrameLength;

            wrapper.append( pagination );
                        
            // build pagination links
            for ( var i = 0, p = 1; i < curFrameLength; i++, p++ ) {
                
                isSelected = frameIndex === i;
                selected = isSelected ? selected : '';
                current = isSelected ? options.frameCurrentText : '';
                frameText = options.frameText.replace( rNumber, p ).replace( rTotal, curFrameLength );
                
                frameLinks.push(
                    frameLink.replace( rNumber, p )
                        .replace( rCurrent, current )
                        .replace( rSelected, selected )
                        .replace( rTotal, curFrameLength )
                        .replace( rFrameText, frameText )
                );
            }
                        
            this.pagination = pagination.append( frameLinks.join('') );
            this.paginationLinks = pagination.find( 'a' );
            pageLink = this.paginationLinks.get(0);
                        
            if ( this.options.centerPagination ) {
                
                // calculate width of pagination wrapper and center beneath carousel
                pageLinkWidth = pageLink.outerWidth(true);
                paginationWidth = pageLinkWidth * curFrameLength;
                
                pagination.css({
                    'width': ( pageLinkWidth * curFrameLength ) + 'px',
                    'left': ( ( self.viewportWidth / 2 ) - ( paginationWidth / 2 ) ) + 'px'
                });
            }
            
            pagination.delegate( '.carousel-frame', 'click', function(e) {
                
                var element = $( this ),
                    frame = element.attr( 'data-carousel-frame' );
                                
                e.preventDefault();
                
                if ( self.carousel.hasClass( 'state-busy' )
                    || element.hasClass( 'selected' ) ) return false;
                                
                loop && frame++;
                
                self.jumpToFrame( frame );
            });
            
        },
                
        jumpToTile: function( tile ) {
            
            var state = this.state,
                tile = parseInt( tile, 10 ),
                index = tile - 1;
            
                index = index < 0 
                    ? 0
                    ? index > state.curTileLength
                    : state.curTileLength - increment
                    : index;
                        
            if ( index === state.index
                || tile > state.curTileLength - state.spacers ) return this.carousel;

            this.updateState( index, true );
            return this.carousel;
        },
        
        jumpToFrame: function( frame ) {
            
            var self = this,
                state = self.state,
                frame = parseInt( frame, 10 ),
                increment = self.options.increment,
                index = ( frame * increment ) - increment;
            
            index = index < 0 ? 0 : index;
                                    
            if ( index === state.index
                || frame > state.curFrameLength ) return self.carousel;
            
            this.lazyloadImages( index, index + increment );
            
            this.updateState( index, true );
            
            return self.carousel;
            
        },

        prevFrame: function() {
            
            var index = this.state.index;
            
            if ( this.options.incrementMode === 'tile' ) index--;
            else index = index - this.options.increment;
            
            this.updateState( index, true );
            return this.carousel;
            
        },
        
        nextFrame: function() {
            
            var index = this.state.index;
            
            if ( this.options.incrementMode === 'tile' ) index++;
            else index = index + this.options.increment;
            
            this.updateState( index, true );
            return this.carousel;
            
        },
        
        reset: function() {
            
            var self = this,
                state = self.state,
                index = state.index,
                options = self.options;
            
            if ( options.loop ) index = options.increment;
            else index = 0;
            
            self.updateState( index, true );
            
            return this.carousel;
            
        },
        
        animate: function() {
            
            var self = this,
                state = self.state,
                index = state.index,
                targetIndex = index,
                options = this.options,
                carousel = this.element,
                loop = options.loop,
                increment = options.increment,
                tileWidth = state.tileWidth,
                preFrameChange = options.preFrameChange,
                postFrameChange = options.postFrameChange,
                isFirst = index === 0,
                isLast = index === ( state.curTileLength - increment );
            
            self.carousel.trigger( 'preFrameChange', [ state ] );
            preFrameChange && preFrameChange.call( self, state );
            
            carousel.addClass( 'state-busy' );
            self.toggleAria( state.tileArr, 'remove' );
            self.updateNavigation();
            
            self.viewport.stop().animate({ 
                
                scrollLeft: state.offset
                
            }, options.speed, options.easing, function() {
                
                if ( !loop ) {
                    
                    self.lazyloadImages( index + increment, index + increment * 2 );

                } else {
                    
                    if ( isFirst || isLast ) {
                        if ( self.updateState( index, false ).loopReset )
                            self.viewport[0].scrollLeft = state.offset;
                    }
                    
                    if ( isFirst ) targetIndex = state.curTileLength - increment * 2;
                    self.lazyloadImages( targetIndex, targetIndex + increment ); // current frame
                    self.lazyloadImages( targetIndex - increment, targetIndex ); // previous frame
                    self.lazyloadImages( targetIndex + increment, targetIndex + increment * 2 ); // next frame
                    
                }
                
                self.updateDisplayCount();
                self.toggleAria( state.tileArr, 'add' );
                self.toggleAria( state.curFrame, 'remove' );
                state.curTile.focus();
                carousel.removeClass( 'state-busy' );
                
            });
            
            self.carousel.trigger( 'postFrameChange', [ state ] );
            postFrameChange && postFrameChange.call( self, state );
                        
        },
        
        lazyloadImages: function( start, stop ) {
            
            var self = this,
                tiles = self.state.tileObj;

            if ( this.lazyloadCache[ start ] ) return;
            
            for ( var i = start; i < stop; i++ ) {
                                
                self.lazyloadCache[i] = true;
                
                $('img', tiles[i] ).each( function() {
                    
                    if ( !this.src ) this.src = $( this ).attr( 'original' );

                });
            }
        },
        
        updateDisplayCount: function() {
            
            var first,
                last,
                current,
                self = this,
                state = self.state,
                index = state.index,
                options = self.options,
                increment = options.increment,
                curTileLength = state.curTileLength - state.spacers;
                
            if ( !options.displayCount ) return;
            
            if ( options.loop ) index -= increment;
            
            last = index + increment > curTileLength
                ? curTileLength
                : index + increment;
            
            first = index + 1;
                        
            spanText = first;
            
            spanText += first < last
                ? '-' + last
                : first; // There's only one frame
            
            this.counter.html( 
                options.counterText
                    .replace( '{number}', spanText )
                    .replace( '{total}', curTileLength )
            );
            
        },
        
        toggleAria: function( itemArray, operation, initClass ) {
            
            var item,
                classes,
                i = 0,
                self = this,
                state = self.state,
                length = itemArray.length,
                ariaHClass = ' state-hidden',
                ariaVClass = ' state-visible',
                rAriaHClass = /\sstate-hidden/,
                rAriaVClass = /\sstate-visible/,
                rSpacerClass = /carousel-panel-spacer/,
                add = operation === 'add' ? true : false,
                initClass = initClass ? ' ' + initClass : '',
                hasAriaInited = this.cache( 'hasAriaInited' );
                        
            for ( ; i < length; i++ ) {
                
                item = itemArray[i];
                classes = item.className + initClass;
                
                if ( rSpacerClass.test( classes ) ) continue;
                
                if ( add ) classes = classes.replace( rAriaVClass, ariaHClass );
                else classes = classes.replace( rAriaHClass, ariaVClass );
                
                item.className = classes.replace( /^\s/, '' );
                
                if ( !hasAriaInited ) {
                    item.className = item.className + ariaHClass;
                    item.setAttribute( tabindex, '-1' );
                }
                                                                
                classes = null;
            }
                        
            this.cache( 'hasAriaInited', true );
            
        }
        
    };
    
    $.fn.tileCarousel = function( options ) {
        
        if ( !this.length ) return;
        
        return this.each(function( i, item ) {
            
            var instance = $.data( this, 'tileCarousel' );
            
            if ( instance ) return instance;
            
            $.data( this, 'tileCarousel', new $.TileCarousel( this, options ) );

        });
    };
    
})( this, jQuery );